#!/usr/bin/perl 

############################################################################
############################################################################
##
## Program for backing up the iServer database and config files.
##
## Run it as follows: dbback [vhd] -f <config_file>
##
## where <config_file> contains the relevant information for backing up
## the database.
##
## Format of the <config_file>
##
## remaddrs = a.b.c.d & ftp.nextone.com
## username = <userid>
## passwd = <passwd>
## remdir = <full_path_of_where_files_are_to_be_put>
## interval = 
## logfile = <full_pathname_of_logfile>;
############################################################################
############################################################################
##
## Copyright 2002, NexTone Communications, Inc.
##
############################################################################
############################################################################


## GLobal defaults
$ISERVER_ROOT	= "/usr/local/nextone";
$ISERVER_BIN	= "$ISERVER_ROOT/bin";
$ISERVER_ETC	= "$ISERVER_ROOT/etc";
$ISERVER_DB		= "$ISERVER_ROOT/databases";
$ISERVEREXEC	= "$ISERVER_BIN/gis";
$ISERVERCLI		= "$ISERVER_BIN/cli";
$VERSION		= "0.5, 04/05/02";
$SELFID			= `basename $0`; chop $SELFID;
$CFGFILE		= "$SELFID.cfg";
$INFOFILE		= ".dbbackinfo";
$MODULE			= "nextone";

## Other variables
$TmpDir			= "/tmp";
$DbPackageName	= "dbpkg.tar";
$CfgPackageName	= "cfgpkg.tar";
$DbPackage		= "$TmpDir/$DbPackageName";
$CfgPackage		= "$TmpDir/$CfgPackageName";
$DOPACK			= "/usr/bin/tar cvf";
$IserverDir		= "$ISERVER_ETC";
$StartDir		= "$ISERVER_ETC";	# typical default
$DBPATH			= "$ISERVER_DB";  	# Dir where database can be picked up
$DBFILES		= "*.gdbm"; 		# All the files in the database
$CFGPATH		= "$ISERVER_BIN";  	# Dir where configuration can be picked up
$CFGFILES		= "*.cfg *.val"; 	# All the files in the database

## Lexical tokens
$T_BACKUP_ALL	= "all";
$T_BACKUP_DB	= "db";
$T_BACKUP_CFG	= "cfg";

$T_DISP_OVERWRITE	= "overwrite";
$T_DISP_ROTATE		= "rotate";

$T_TYPE_ACTIVE	= "active";
$T_TYPE_PASSIVE	= "passive";

$T_PROT_FTP		= "ftp";
$T_PROT_RSYNC	= "rsync";

## Some Initializations
$PROT_TRANS		= $T_PROT_FTP; 	# Default Transfer Protocol
$Start			= 0;			# Start reading relevant section of the config file. 
$ncop			= 3;			# Default number of copies if rotation is used. 
$logging		= 0;			# Logging is off be default



##
## Preliminary
##

use lib "/usr/local/nextone/lib/perl5/site_perl";

if ($ENV{BASE})
{
	use lib "$ENV{BASE}/lib/perl5/site_perl";
}

## Start
use Getopt::Std;
use English;


## Command line options
getopts ("dhvf:r");

if ( -x $ISERVEREXEC )
{
	if (!  -x $ISERVERCLI )
	{
		die "Cannot find iServer CLI!!";	
	}
}
else {
	die "Cannot find iServer!!";
}


if ($opt_h)
{
	print "Help is on the way\n";
	print "Use \"perldoc $SELFID\" to view documentation. \n";
	exit 0;
}

if ($opt_v)
{
	print "$SELFID version: $VERSION \n";
	exit 0;
}

if ($opt_f)
{
	$CFGFILE = $opt_f;
}

if ($opt_r)
{
	$PROT_TRANS = "rsync";
}

print "$SELFID version: $VERSION \n";
print "Config file is $CFGFILE \n\n";

CheckForSuperuser ();

$StartDir = `pwd`;
chop $StartDir;

ReadInfo ();

## Adjust sequence numbers;
$nseqno = $seqno + 1;
print "Sequence = $nseqno\n";

print "Tranport mechanism is $PROT_TRANS \n";
## Read the config file
ReadConfig ();

if ($T_DISP_ROTATE)
{
	$revno = $nseqno % $ncop;
}

if ($PROT_TRANS eq "rsync")
{
	if ($logging) { open (FP, ">>$logfile") or warn "Cannot open $logfile $! \n"};
	MakePackage ();
	SyncFiles ();
	if ($logging) { close (FP) };
}
else
{

	MakePackage ();

	DoFTP ();
}

GenInfo ();




########################################################
########################################################
#### Subroutines start here.
########################################################
########################################################
sub GenInfo ()
{
	my $curtime = time ();
	my $date = `date`;

	chop $date;

	## Get back to directory.
	chdir $IserverDir or die "Cannot cd to $Iserverdir: $! \n";

	open (IFP, ">$INFOFILE") or die "Cannot open $INFOFILE $! \n";

	print IFP <<eEOF
##
## Generated by $SELFID, $VERSION
## on $date
##
lasttime = $curtime
seqno = $nseqno
eEOF
;
	close IFP;
}



sub ReadInfo ()
{
	my $curtime = time ();
	my $status = 0;

	chdir $IserverDir or die "Cannot cd to $Iserverdir: $! \n";

	if ( ! -f $INFOFILE )
	{
		$status = system ("/usr/bin/touch $INFOFILE");
	}

	open (IFP, $INFOFILE) or die "Cannot open $INFOFILE $! \n";

	while ( <IFP> )
	{
		## Ignore comments
		next if m/^#.*/ ;

		chop;

		if ( m/.*lasttime.*=(.*)/ )
		{
			$lasttime = $1;
			for ($lasttime) 
			{ 
				s/^\s+// ; 
				s/\s+$// ; 
			}
			print "lasttime: $lasttime\n";

			if ($lasttime > $curtime)
			{
				print "Error in backing up. Time not synced.\n";
			}
		}
		if ( m/.*seqno.*=(.*)/ )
		{
			$seqno = $1;
			for ($seqno) 
			{ 
				s/^\s+// ; 
				s/\s+$// ; 
			}
			print "seqno: $seqno\n";
		}
	}

	close IFP;
}


sub MakePackage ()
{

	if ($backup eq $T_BACKUP_ALL)
	{
		PackDB ();
		PackCfg ();
	}

	if ($backup eq $T_BACKUP_DB)
	{
		PackDB ();
	}

	if ($backup eq $T_BACKUP_CFG)
	{
		PackCfg ();
	}
}

sub PackDB ()
{
	my $dbpath = $ISERVER_DB;
	my @files;
	
	## Change directory
	chdir $dbpath or die "$dbpath: $!\n";
	@files = glob("*.gdbm");
	$dbexport = "$ISERVERCLI db export ";
	$DbSaveFile = "$TmpDir/dbsave.$revno";

	## Process the files first

	$status = system ("$dbexport $DbSaveFile");

	if ($status)
	{
		print "Error in exporting database. \n";
	}

	chdir $TmpDir or die "$TmpDir: $! \n";
	$status = system ("$DOPACK $DbPackage dbsave.$revno");
	if ($status)
	{
		print "Error in packing database. \n";
	}

}

sub PackCfg ()
{
	my @files;

	chdir $CFGPATH or die "$CFGPATH: $!\n";
	
	@files = glob ($CFGFILES);

	$status = system ("$DOPACK $CfgPackage @files");

	if ($status)
	{
		print "Error in packing Config.\n";
	}
}


sub DoFTP ()
{
	use Net::FTP;
	my $ftp;
	my $addr;
	my $i = 0;
	my $RemoteDbPackage;
	my $RemoteCfgPackage;
	my $DbPut;
	my $CfgPut;

	foreach $addr (@remaddrs)
	{
		## Initialize the connection
		print "FTP to $addr ...";

		$ftp = Net::FTP->new($addr);

		$ftp->login ($userids[$i], $passwds[$i]) or die "Cannot ftp: $@";
		$ftp->cwd ($remdirs[$i]) or die "No directory: $!";
		$ftp->binary ();


		if ($disp eq $T_DISP_OVERWRITE)
		{
			$RemoteDbPackage = $DbPackage;
			$RemoteCfgPackage = $CfgPackage;
		}
		else	## sequence
		{
			## Make up the full name.
			$RemoteDbPackage = $DbPackage . $revno;
			$RemoteCfgPackage = $CfgPackage . $revno;

			## Rename locally, before sending
			rename ($DbPackage, $RemoteDbPackage);
			rename ($CfgPackage, $RemoteCfgPackage);
		}

		$DbPut = $RemoteDbPackage;
		$CfgPut = $RemoteCfgPackage;


		## Put the files on the remote host
		if ($backup eq $T_BACKUP_ALL)
		{
			$ftp->put ($DbPut);
			$ftp->put ($CfgPut);
		}
		if ($backup eq $T_BACKUP_DB)
		{
			$ftp->put ($DbPut);
		}
		if ($backup eq $T_BACKUP_CFG)
		{
			$ftp->put ($CfgPut);
		}


		## End the connection.
		$ftp->quit ();

		print "..done\n";

		$i++;
	}
}

sub ReadConfig ()
{

	chdir $StartDir or die "Cannot cd to $StartDir: $! \n";

	open (FP, $CFGFILE) or die "Cannot open $CFGFILE: $!";

R_LOOP:	while ( <FP> )
	{
		## Ignore comments
		next if m/^#.*/ ;

		chop;

		if ( ($PROT) = ($_ =~ m/^\[(.*)\]/) )
		{
			last R_LOOP if ($start);
			if ($PROT eq $PROT_TRANS)
  			{
				$start = 1;
			}
		}
		
		#if ($start && ($PROT_TRANS eq $T_PROT_FTP) )
		if ($start)
		{
			if (m/remaddrs.*=(.*)/)
			{
				@remaddrs = split(/&/, $1);
				foreach $i (@remaddrs)
				{
					print "remaddr: $i\n";
				}
				## Remove leading whitespace
				for (@remaddrs) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
			}
			if (m/username.*=(.*)/ )
			{
				@userids = split(/&/, $1);
				foreach $i (@userids)
				{
					print "userids: $i\n";
				}
				## Remove leading whitespace
				for (@userids) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
			}
			if ( m/.*passwd.*=(.*)/ )
			{
				@passwds = split(/&/, $1);
				foreach $i (@passwds)
				{
					print "passwds: $i\n";
				}
				## Remove leading whitespace
				for (@passwds) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
			}
			if ( m/.*remdir.*=(.*)/ )
			{
				@remdirs = split(/&/, $1);
				foreach $i (@remdirs)
				{
					print "remdirs: $i\n";
				}
				## Remove leading whitespace
				for (@remdirs) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
			}
			if ( m/.*logfile.*=(.*)/ )
			{
				$logfile = $1;
				for ($logfile) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
				print "logfile: $logfile\n";
				$logging = 1; 	#Logging is switched on 
			}
	
			if ( m/.*disp.*=(.*)/ )
			{
				$disp = $1;
				$disp =~ s/^\s+// ; 
				@disparr = split(/\s+/, $disp);
				for (@disparr) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
				$disp = $disparr[0];
				$ncop = $disparr[1];
				print "disp: $disp\n";
				if ($ncop) 
				{ 
					if ($ncop !~ /^[0-9]+$/)
					{
						die "Number of copies is not an integer\n";
					}
					print "ncop: $ncop\n";
				}
			}
	
			if ( m/.*backup.*=(.*)/ )
			{
				$backup = $1;
				for ($backup) 
				{ 
					s/^\s+// ; 
					s/\s+$// ; 
				}
				print "backup: $backup\n";
			}
	
			if ( m/.*type\s+=(.*)/ )
			{
				$btype = $1;
				for ($btype)
				{
					s/^\s+// ;
					s/\s+$// ;
				}
			}
		}
		#elsif ($start && ($PROT_TRANS eq $T_PROT_RSYNC) )
		#{
		#}
	}

	close (FP);
}

sub CheckForSuperuser ()
{
	my $logname = $ENV{'LOGNAME'};

	if ($logname ne "root")
	{
		print "You need to be a superuser to run dbback!\n";
		exit 0;
	}
}

sub SyncFiles ()
{
	use File::Rsync;
	$dirpath; 
	@files;
	
	$rsync = File::Rsync->new;
	%RsyncOpt = ('verbose' => 1);
	%RsyncOpt = ( %RsyncOpt, 'archive' => 1);
	%RsyncOpt = ( %RsyncOpt, 'compress' => 1);
	if (($backup eq $T_BACKUP_ALL) || ($backup eq $T_BACKUP_DB))
	{
### Old approach was to rsync the whole directory
### New approach is to do exactly what ftp is doing 
#		$dirpath = $DBPATH;
#		chdir $dirpath or die "$dirpath: $!\n";
#		@files = glob($DBFILES);
#		($#files >= 0)  or die ("No src file $DBFILES to sync in $dirpath: ");
		$srcfile = $DbPackage;
		if ($disp eq $T_DISP_OVERWRITE)
		{
			$dstfile = $DbPackageName;
		}
		else
		{
			$dstfile = ($DbPackageName . $revno);
		}
		%RsyncOpt = ( %RsyncOpt, 'src' => "$srcfile");
	
		foreach $addr (@remaddrs)
		{
			foreach $remdir (@remdirs)
			{
				%RsyncOpt = ( %RsyncOpt, 'dest' => "$addr\:\:$MODULE/$remdir/$dstfile");
		        	if (!($rsync->exec(\%RsyncOpt)) && $logging) 
				{
					$rval = $rsync->status;
					print FP "rsync failed with return status $rval\n";
					$errstr = $rsync->err;
					for ($i = 0; $i <= $#{$errstr}; $i++){print FP "$errstr->[$i]";} 
				}
			}
		}
	}
	if (($backup eq $T_BACKUP_ALL) || ($backup eq $T_BACKUP_CFG))
	{
#		$dirpath = $CFGPATH;
#		chdir $dirpath or die "$dirpath: $!\n";
#		@files = glob($CFGFILES);
#		($#files < 0)  && die ("No src file $CFGFILES to sync in $dirpath: ");
		$srcfile = $CfgPackage;
		if ($disp eq $T_DISP_OVERWRITE)
		{
			$dstfile = $CfgPackageName;
		}
		else
		{
			$dstfile = ($CfgPackageName . $revno);
		}
		%RsyncOpt = ( %RsyncOpt, 'src' => $srcfile);
	
		foreach $addr (@remaddrs)
		{
			foreach $remdir (@remdirs)
			{
				%RsyncOpt = ( %RsyncOpt, 'dest' => "$addr\:\:$MODULE/$remdir/$dstfile");
		        	if (!($rsync->exec(\%RsyncOpt)) && $logging) 
				{
					$rval = $rsync->status;
					print FP "rsync failed with return status $rval\n";
					$errstr = $rsync->err;
					for ($i = 0; $i <= $#{$errstr}; $i++){print FP "$errstr->[$i]";} 
				}
			}
		}
	}
}
